## Первая строка - интерпретатор
!# /bin/bash

параметры 

```set -v``` - выводить все строки на экран
```set -x``` - выводить все комманды и их параметры

также\
```/bin/bash -v SCRIPT.sh```\
```/bin/bash -x SCRIPT.sh```

## Переменые присваивание
```bash
a = 2
read a
a = $(..COMMAND...)
a = '...COMMAND...'
```
$(...) - подстановка результата комманды
<(...) - подстановка имени временного файла

_опции read_\
-p - задать текстовую строку для вывода\
-r - запретить обратный слеш для экранирования символов

### Расширение оболочки
вызвать переменную ```$VARIBLE```\
echo ```${var_name:-TEXT}``` если переменна существует - она напечатается, если нет- текст после ```:-```

+ - выведется значение после + есл объявлена
= присваивает значение и выводит
/ удалить чтото
/лрлл/рпрп заменить на

[Расширение параметров оболочки](https://runebook.dev/ru/docs/bash/shell-parameter-expansion)

## Математические расчеты

```bash
let a=2+2
((a=2+2))
a = "4 + 4 = $((4+4))"
на необходимость расчетов указывают  двойные скобки или let
((a++)) увеличить на еденицу
((a--))
((a*=3)) умножить на 3
((a/=4))

% - остаток от деления
```

bash работает только с целыми числами, для дробных нужет бинарный калькулятор

## Шаблоны
```*``` - любое количество символов\
```?``` - один любой символ\
```\``` - экранировать "специальность" символа\
_Чтобы экранировать звездочку или знак вопроса используем любые ковычки_
_Правильные кавычки для символа доллор %_\
"asdf$VAR" - __в двойных__ кавычках происходит подстановка переменных\
'asfda$VAR_NO' - __в одинарных__ кавычках переменные не подставляются

## Коды возврата
Код возврата после каждой комманды оставется в переменной ```$?```

программы которые возвращают всегда определенные коды возврата
```bash
/bin/false или  false - всегда возвращает 1
/bin/true или true - всегда возвращает 0
```

## Условный оператор IF
__ОБЯЗАТЕЛЬНО ПРОБЕЛЫ ПОСЛЕ И ДО СКОБОК__
```bash
if [[ cmd1 ]] && [[ cmd2 ]]; then  COMMAND2; - чтобы выполнилось cmd1 cmd2 должны вернуть 0 && - логическое И
elif [[ cmd3]] || [[ cmd3 ]]; then command4; - || - логическое ИЛИ (опционально)
else command5; (опционально) 
fi; - закрываем IF
```

[[ ОПЦИЯ КОММАНДА ]]
[[ ПЕРЕМЕННАЯ ОПЦИЯ ПЕРЕМЕННАЯ ]]

_опции при проверке файлов_\
-e - существует файл или дирректория\
-f - существет файл (! -f - не существует)\
-d - существует дирректория\
-s - существет файл и он не пустой\
-r - существует файл и доступен для чтения\
-w - существует файл и доступен для записи\
-x - существует файл и доступен для выполнения\
-h - символьная ссылка

_опции для строк_\
-z - пустая строка\
-n - не пустая строка\
== - равной\
!= - не равно

_опции с числами_\
-eq - равно\
-ne - не равно\
-lt - меньше\
-le - меньше равно\
-gt - больше\
-ge - больше равно

### Альтерантива if
Комманда1; Комманда2 - комманда 2 выпонится в любом случае\
Комманда1 && Комманда2 - комманда 2 выпонится если 1 выполнится без ошибок\
Комманда1 || Комманда2 - комманда 2 выпонится если 1 с ошибками

## Условный оператор CASE
синтаксис\
```bash
case "$VAR1" in  
condidion1) com1
;;
condition2) com3
;;
test.png|*.jpg) com4  (ИЛИ)
;;
*) com5
esac
```

## Потоки ввода вывода
0 - стандартный ввод\
1 - стандартный вывод\
2 - вывод ошибок\

поток ошибот не перенаправляется через __pipeline__

_поиск текста в файлах директории_
```grep -R "TEXT" /dir 2 >error или 2> /dev/null```\
ошибки направляем в файл error или в пустоту
КАК ПЕРЕНАПРАВИТЬ ОШИБКИ В ПУСТОТУ ДЛЯ ВСЕГО ФАЙЛА?

## Передача аргументов скрипту
```./script.sh arg1 arg2 arg3```
обращение внутри скрипта ```$1 $2 $3```
$0 - название скрипта

## Цикл WHILE
```bash
i=0
while [[ $i -le 4 ]]; do
  echo $i
  ((i++))
done
```

``` while true; do .....```

$RANDOM%10 - остаток от деления случайного числа на 10 - случайное число от 0-9

## Цикл FOR
```bash
for item in cofe tee water; do
            (array)
echo $item
done

for file in /tmp/*; do

for file in "$DIRNAME"/*; do

for file in *; do

for ((i=0; i < 10; i++ )); do

for ((i=0; i < 10; i+=2 )); do
```

## Использование SELECT
сама конструкция select - бесконечная

```bash
select pill in red blue; do
  case $pill in
    red)
    echo "you will know the truth"; break;;
    blue)
    echo "you won't know anything"; break;;
  esac
done

```

```breake``` - выход из тела цикла ..

## Функции в BASH

FUNCTION_NAME () {
  commands
  ...
  }
  
```bash
division () {
  if [[ $2 -ne 0 ]] then
    echo "$1/$2 = $(($1/$2))"
  else
    echo "division by zero"
  fi
}

read_args() {
  echo $@
  for item in $@; do
    echo $item
  done
}

```
в функцию можно передать любое количество параметров,и\
обращаться к ним внутри $1 $2\
в переменную $@ передаются все аргументы\

## Выход из функции и коды возврата

```return КОД``` - выход из функции, по умолчанию код = 0
```exit КОД``` - выход из скрипта, по умолчанию код = 0

### Спецсимволы
```echo -e "asd\ndfg"```
\045 - знак доллара
\x09 - табуляция
вставить ТАБ в строку ctrl+v далее "TAB"

## Регулярные выражения
"^" - начало строки\
"$" - конец строки\
"." - любой символ, обязятельно присутсвует\
[] [a-z][A-Z] - диапазон символов\
[^a-z] - исключение символов\
\* - любое количество символов (предыдущих) или отсутсвие\
.* - любые символы и любое их количество\
[c-e]* - любое количество любых символов из скобок\
\+ - одно или большее количество предыдущих символов\
? - одно наличие или отсутсвие предыдущего символа или диапазона \
_квантификаторы, задают количество повторений символа_\
{4} - 4 раза\
{4,} - не меньше 4 раз\
{4,7} - от 4 до 7 раз\
{,7} - не больше 7 раз\
аналоги\
\* = {0,}\
\+ = {1,}\
? = {0,1}\
_применение квантификаторов к группе символов_\
(...) - скобки показывают, что кванти применяются к группе\
"|" - логическое ИЛИ также применяется\
(Москва|Казань|Ленинград)+ - совпадение с одним из городов один или больше раз. даже если они без пробела

"\" - экранирование следующего символа\
^(https?:\/\/)?(www\.)?[a-z0-9\-]+\.[a-z]{2,4}$

## GREP
grep -E 'regexp' file - можно применять расщиренные регулярные выражения\
-E — расширенное регулярное выражение (Extended Regexp)\
-v — инверсия вывода\
-с — подсчёт количества выводимых строк вместо их вывода\
-n — вывод номера строки\
-i — нечувствительность к регистру\
-r — рекурсивный поиск по всем файлам\

```tail - f /var/log/syslog | grp -E "\] (0-9){3} new objects"```

## SED 
_потоковый текстовый редактор - редактирует входящий текстовый поток с помощью регулярных выражений_\
sed 's/ads/dfas/g' file1 > file2\
's/' - режим замены 'ads' на 'dfas' '/g' - глобал все вхождения заменить

-E — позволяет использовать регулярные выражения в sed\
sed 'pattern/d' — удаляет строки, содержащие символы из pattern\
-i, --in-place — производит замену в изначальном файле file\
Если после ключа указать текст, будет создан бэкап

```bash
sed -Ei 's/Port [0-9]+/Port 2222/' file - заменить текст
sed -У '/^[^1-8]/d' FILE - удалить из файла строки без цифр 1-8 в начале
cat FILE sed -У '/^[^1-8]/d'  - удалить из ПОТОКА (для тренировки) строки без цифр 1-8 в начале
```

## AWK
_мощьный кекстовый редактор, скриптовый язык. входные данные можно представить как таблицы, строки - строки, слова столюцы - разделитель по умолчанию - пробел_
_параметры_\
```ps aux | awk'{ print $1 " " $11,$3 }'```\
секция BEGIN определяет начальные переменные\
```ps aux | awk' BEGIN { OFS=" ---" } { print $1 " " $11,$3 }'```\

$0 - вся строка целиком\
$1 - 1й столбец\
$2 - 2й стоблбец\
"-F РАЗДЕЛИТЕЛЬ" -  задает разделитель\

```bash
print
var = 'value'
if-then-else
while (i>0){}
```
_условие_\
```ps aux | awk'{ if ($2 <90000) print $1 ,$2 }'```
_цикл_\
``` cat /proc/loadavg awk '{ sum=0; i=1; while (i<4) {sum+=$i; i++} print $sum/3  }' ```
_сортировка и вывод уникальных значений_
``` cat access.log | awk '{ print $9 }' | sort | uniq```\
'uniq' правльино работает только после сорт - уаляет одинаковые подряд идущие значения\
```uniq -c``` - вывести уникальные значения и подсчитать их количество\

_встроенные переменные_
FS — разделитель столбцов\
RS — разделитель строк\
OFS — выходной разделитель столбцов\
ORS — выходной разделитель строк\

awk -f FILE - вызов скритпта из файла

a=gensub("WHAT","ON WHAT","g", WHERE - $3); print a - внутри awk функция замены, в двнном случае - глобальной. Текст помещаем в 'a'\
__gensub в пакете gawk__\
_анализ трафика - в дампе TCP орезаем порт и выводим только только перенаправления откуда, куда_
```bash
cat tcpdump.txt | awk -f awk_script
{a=gensub("\.[a-z0-9]+$","","g",$3);b=gensub("\.[a-z0-9:]+$","","g",$5); print a $4 b;}
```

В работе с условным оператором if можно использовать таблицу проверочных выражений для работы с файлами, текстом и числами
Можно использовать логические операторы && и || без условия if
Пример использования условного оператора if
if [[$port == ‘80’ || $port == ‘80’]]; then
echo "This is HTTP"
elif [[ $port == ‘22’ ]]; then
echo "This is SSH"
else if [[ $port == ‘53’ ]]; then
echo "And this is DNS"
else
echo "I dont know what is that"
fi;

Условный оператор case применяется для сравнения одной переменной с различными вариантами текстовых значений

Шаблоны * и ? можно применять в case
Условный оператор case, в отличии от if, не применяется для сравнения чисел
Пример использования условного оператора case
case “$port” in
(‘80’|‘8080’)
echo “This is HTTP”
;;
‘22’)
echо “This is SSH”
;;
‘53’)
echo “And this is DNS”
*)
echo “I dont know what is that”
;;
esac

Отладка - это этап разработки программы, на котором разработчик обнаруживает, локализует и устраняет ошибки

С помощью опции -x, -v в bash можно производить отладку своих скриптов
После изучения теоретического материала рекомендуем приступить к практике. Повторите самостоятельно то, что эксперт показывал во время лекции на скринкастах. Далее выполните задания в тренажёрах с автоматической проверкой, чтобы закрепить навык создания простейших bash-скриптов с ветвлением.

