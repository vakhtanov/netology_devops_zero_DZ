## Стандартный пароль к VM Windows *Passw0rd!*  
[коробки с операцинными системами](https://www.osboxes.org/ubuntu/)

`sudo apt install mc` - установить коммандер  

`winscp` - програма для передачи файлов по ssh  

## Инфа о системе

`cat /etc/os-realease` - релиз операционки  
`cat /proc/cpuinfo` - про процессор  
`cat /proc/version` - версия операционки  
`cat /proc/stat` - системная статистика  
`cat /proc/cmdline` - параметры запуска системы    
`uname -a ` - информация о типе системы и версии ядра
`lsb_release -a` - информация о сборвке и версии
`lscpu` - информация о процессоре
`lshw` - информация об аппаратных ресурсах

`who -r` - посмотреть уровень запуска операционной системы  
`file /sbin/init` - какая система инициализации  

`echo $SHELL` - текущая оболочка  
`cat /etc/shells` - установленные оболочки  

`pidof [proc name]` - показывает PID процесса с именем  
`tee` - читает из stdin и напрвляет куда надо можно одновременно вывести на экран и записать    
`$$` - PID текущего процесса  
`id, sudo id` - информация о текущем пользователе и группах в которых он состоит  

`type NAME` - тип объекта  
`which NAME` - где исполняемый файл

`w` - действующие сессии терминала  
`whoami` - имя текущего пользователя  
`export NAME=XXXXX` - задать переменную во все дочерние процессы   
`NAME=XXXXX` - задать переменную в текущей оболочке  
`export -n NAME` - удаление переменной  

`lscpu` `cpuinfo` - инфа о проце  

`uname -a или uname -r` - версия ядра
glibc - библиотека для общения с системмнымии вызовами

`wc -l` - счетчик линий  
`wc -w` - счетчик слов  
`wc -m` - счетчик символов  

`file NAME` - показывает тип файла  
`command -v NAME` - показывает что запустит комманда  

`/bin, /usr/bin, /sbin, /usr/sbin` — исполняемые файлы (программы)  
`/boot — файлы загрузчика/dev` — представление устройств в виде файлов  
`/etc` — конфигурационные файлы/home  
`/home/inus` — домашний каталог пользователя linus __Можно класть в оделный раздел для большего места для пользователей__  
`/root` — домашний каталог пользователя root  
`/lib, /usr/lib` — библиотеки и модули ядра  
`/tmp` — каталог для временных файлов (очищается после перезагрузки)  
`/var` — каталог для изменяющихся файлов: логи, базы данных и т. д. __Можно класть в оделный раздел для защиты от переполнения__  
`/usr/local, /opt` — каталоги для программ, которые устанавливаются вручную  

`lspci` для устройств PCI
`lsusb` для USB-устройств
`lspcmcia` для карт PCMCIA

__лог сообщений ядра__\
`/var/log/dmesg`\
`dmesg`

## Структурные единицы LINUX
__system.d__\
__шедулер__ - планировщик управляет распределение ппроцессорного времени для программ\
многоядерные процессоры появились в 2004 году.\
В текущих версиях Linux планировщие CFS или есть альтернативный SCHED_DEDLINE Это планировщики процессорного времени\
есть планировцики ввода-вывода часто используется CFQ, BFQ/deadline, noop\
` /sys/block/устройство/queue/scheduler`\

## модули ядра
`lsmod` — информация обо всех загруженных модулях\
`modinfo <MODULE-NAME>` — просмотр информации о модуле\
`modprobe <MODULE-NAME>` — загрузка модуля\
`insmod /lib/modules/.../<MODULE-NAME>.ko` — загрузка модуля с помощью insmod\
`rmmod <MODULE-NAME>` — выгрузка модуля

__Примеры системных вызовов:__
`open, read, write, close`\
Документация доступна во втором разделе man:\
`man 2 <syscall-NAME>` — поиск документации по системному вызову\
`tldr` - лучше чем `man`

`strace` — утилита для отслеживания системных вызовов при выполнении процесса\
`strace <команда>` — отслеживание системных вызовов приложения

__Работа с dkms__\
`dkms add -m <MODULE-NAME>` — добавление модуля в dkms\
`dkms status` — проверка статуса модуля в dkms\
`dkms build -m <MODULE-NAME> -v <MODULE-VERSION>` — сборка модуля с помощью dkms\
`dkms install -m <MODULE-NAME> -v <MODULE-VERSION>` — установка модуля с помощью dkms\
`dkms autoinstall` — сборка и установка всех модулей

## Каталог PROC

- cgroup — группа управления процесса
- fd — дескрипторы открытых файлов
- cmdline — командная строка
- environ — переменные окружения
- stat — информация о состоянии процесса (ps)
- statm — информация об использовании памяти
- root — ссылка на корневой каталог процесса

## Комманды оболочки
`pwd` - выводит полный путь до текущего
`cat` - вывести на экран содержимое файла  
`less` - мощьный текстовый пейджер, возможности навигации как у ман  
`more` - постраничный текстовый пейджер, возможности навигации как у ман  
`head, tail` - начало и конец
`\СИМВОЛ` - экранирование символа он будет использоваться как есть, специальное назначение игнорируется  
Выключение: `systemctl poweroff` — аналог устаревшего `shutdown -P now`  
Перезагрузка: `systemctl reboot` — аналог устаревшего `shutdown -r now`  
`sudo -i` - зайти под другим пользователем, в данном случае root, или указать пользователя 
если у рута не задали пароль при установке, то sudo запрашивает пароль текущего пользователя  
`su -` - старая версия sudo работате если у рута есть пароль  
*__Пользователь без пароля не зайдет в систему!!!__*\
`ls -l` - просмотр аттрибутов файлов\
`ls -lia` - просмотр inod\
`ls -a` - просмотр всех файлов включая скрытые\
`ls -ld` - просмотр аттрибутов дирректории\
`ls -lh` - просмотр в человекочитаемом виде\
`touch FILE` - создать новый файл и/или обновить дату редактирования файла\
`truncate -s 0 /path_to_file` - очистка логов, обнуление файлов\
`rm FILE` -удаление файла\
`rm -v FILE` -удаление файла c выводом на экран отчета об операциях\
`rm -r DIR` -удаление всего каталога с содержимым\
`-i` - интерактивный режим, с запросами\
`mkdir DIR, rmdir DIR` - создать, удалить пустые именно директории\ 
`-p`- дерево каталогов\
`-f` - без запроса\
`cp FILE1 FILE2 DIR, cp FILE FILE_TARGET/DIR, mv FILE1 TARGET` - копирвоать/переместить(переименовать) файл\
`-r` - копировать рекурсивно - для каталогов\
`chmode +x` - изменить права, в частности добавить права на исполнение\

`lsblk` - показывает перечень блочных устройств и их точки монтирования\
`df -h` - показать свободное место на устройствах\
`du -sh /DIR` - размер директории\
`sudo mount /dev/УСТРОЙСТВО_РАЗДЕЛ /MOUNTING_POINT` - монитрование раздела в в определенный каталог\
`findmnt -A` точки монтирования между файлами в вашей системе с помощью команды 
`watch` - периодически выполнять комманду\
`tail -f FILE` - следить за файлом и выводит новые строки\
`reptyr PID` - перехватить процес\

## Система инициализации
`file /sbin/init` - какая система инициализации  
`systemctl status` - информация в графическом виде о службах  
`systemd-analyze plot > test.svg` - дерево загрузки
`sudo systemctl list-dependencies` - дерево загрузки 
`systemctl get-default` - в каком состоянии загруки система  
`systemctl --all -t service` - все сервисы  
`systemctl status sshd.service` - просмотр конкретного сервиса  

* `systemctl list-units` — список модулей
* `systemctl list-units` --type=service — список модулей-служб
* `systemctl status <модуль>` — состояние выбранного модуля
* `systemctl enable\disable <модуль>` — разрешить/запретить модуль
* `systemctl start\stop\restart <модуль>` — запустить/остановить/... модуль
* `systemctl daemon-reload` — перезапуск конфигурации system


## Типы файлов в системе\
*Обычные файлы* - `-`\
*Каталоги* - `d`\
*Файлы символьных устройств* - `c` - консоли\
*Файлы блочных устройств* - `b` - диски\
*Сокеты (локальные)* - `s` - передача данных между программами\
*Каналы (pipe)* - `p` - передача данных между программами\
*Ссылки* - `l`\

## Редактор VI VIM  
`Insert клавиша` - переход в режим редактирвоания  
`ESC клавиша` - переход в режим навигации и комманд  
`:wq!` - записать и выйти  
`:q!` - выйти  
`vimtutor` - справка по вим  
еще есть `nano` и `mc`  
`mc` - коммандный менеджер  


## Объединение комманд  
[Справка по объединению](https://housecomputer.ru/os/unix/Operators_combining_teams.html)  
`&` - в конце отправить в фон  
`;` - между коммандами - последовательное выполнение  
`&&` (логическое И) - следующая выполнится только если пердыущая успешно выплнилась - код выхода 0  
`||` (логическое ИЛИ) - следующая выполнится только если пердыущая  выплнилась НЕ УСПЕШНО 
`!!` - подставляет предыдущую комманду  

## Работа с потоками  
stdin - 0
stdout - 1
stderr - 2
`cmd < FILE` - напрвить файл в комманду  
`CMD > FILE` - вывод комманды в файл заменить  
`CMD >> FILE` - вывод комманды в файл дописать  
`CMD 2> FILE` - вывод ошибок в файл  
`CMD1 | CMD2` - вередать вывод первой команды на вход второй  
`find /etc > /dev/null` - стандартный вывод уходит на нулевое устройство, на экран выведутся только ошибки!!!   
`2>&1` - поток ошибок направить в первый поток  
`>&2` - стандартный поток в поток ошибок и он, возможно, выведется на экран  


## Фоновые процессы
`ctrl+z` - отправить процесс в фон - он останавливается  
`ctrl+d` - заверщить процесс   
`ctrl+с` - прервать процесс  
`jobs` - процессы в фоне  
`fg %НОМЕР` - переключение на процесс  

`ctrl+l` - очистить экран    
`ctrl+r` - поиск комманд  

## Работа с APT
https://www.dmosk.ru/miniinstruktions.php?mini=aptly-repo - инструкции по созданию локального репозитория  
`sudo apt update` — обновление индекса пакетов: скачивание информации из репозитория о имеющихся версиях  
`sudo apt upgrade` — обновление самих пакетов  
`sudo apt install package` — установка пакета с названием package  
`sudo apt remove package` — удаление пакета package из системы  
`sudo apt autoremove` — удаление неиспользуемых зависимостей  
`aptitude` - в псевдографике приложения сгруппированы по тематике  
`/etc/apt/sources.list` - файл со списком основных репозиториев\
`/etc/apt/sources.list.d/` - дирректория в которую можно добавить файлы с расширением list с дополнительными репозиториями\
`dpkg -i DEB PAKET` - установить deb пакет без разрешения зависимостей. 
__Для установки стороннего ПО - скачиваем маленький DEB пакет который прописывает нужные репозиротии в sources.list.d, после этого обновляем репозиротии и устанавливаем нужный пакет__\
Сборка из исходников: Собрать бинарники и разложить по дирректориям, или собрать DEB пакет и его установить\
`dpkg-deb --build `  `rpmbuild`

Команда `make` Для сборки нам понадобятся:
* компиляторы, которые прописаны в зависимостях пакета `build-essential`, так что достаточно установить его со всеми зависимостями
* autoconf и automake
* файл configure, необходимый для процесса сборки (в случае его отсутствия надо выполнить: ./bootstrap или ./autogen.sh)



* `apt search <pattern>` – полнотекстовый поиск в репозитории по паттерну
* `apt show <packet_name>` – показывает информацию о пакете (пакетах)
* `apt list` – выводит список пакетов в зависимости от ключа:
  * `--installed` – установленных
  * `--upgradeable` – доступных к обновлению
  * `--all-versions` – всех доступных
* `apt install <packet_name>` – устанавливает в систему пакет программного обеспечения, разрешая, по возможности, зависимости
* `apt remove <packet_name>` – удаляет файлы приложения из системы, но оставляет пользовательские файлы с настройками
* `apt purge <packet_name>` – удаляет все файлы приложения, включая файлы настроек
* `apt reinstall <packet_name>` – переустанавливает пакет в системе
* `apt autoremove` – удаляет неиспользуемые пакеты, например, старые версии ядра
* `apt -f install` – попробует починить поломанную установку пакета, например, неудовлетворенные зависимости



## Работа с YUM
* `yum update` – проводит обновление всех пакетов в системе, перед этим выполняя обновление списка пакетов в репозитории
* `yum update <packet_name>` – обновляет только выбранный пакет
* `yum downgrade <packet_name>` – откатывает пакет к предыдущей версии
* `yum search <pattern>` – полнотекстовый поиск в репозитории по паттерну
* `yum list` – выводит список пакетов в зависимости от ключа:
  * `installed` – установленных
  * `available` – всех доступных пакетов
  * `all` – всех доступных и установленных пакетов
* `yum install <packet_name>` – устанавливает в систему пакет программного обеспечения, разрешая по возможности зависимости
* `yum remove <packet_name>` – удаляет файлы приложения из системы, но оставляет пользовательские файлы с настройками
* `yum reinstall <packet_name>` – переустанавливает приложение в системе
* `yum autoremove` – идентичен применению в APT
* `yum clean packages` – удалит пакеты из кеша

## Работа с python PIP
* `python3 -m pip install <package_name>` – установка выбранного пакета
* `python3 -m pip uninstall <package_name>` – удаление установленного пакета. Пакеты устанавливаются глобально, для всей системы
* `python3 -m  pip install -U` – __обновление пакетов__\
__pip search list show больше не работают__ 


## Работа с экранами и терминалами   
`screen` - запуск экрана - УСТАРЕВШИЙ  
`exit` - выйти из приложения экранов  
`ctrl+а d ` - пеерключиться на основную сессию bash  
`screen -r` - вернуться в screen  
`reptyr PID` - подключиться к процессу - переместить процесс в текущую сессию  

 __альтернатива `tmux` terminal multiplexer - БОЛЕЕ НОВЫЙ__\
`Ctrl+b c` - создать новое окно\
`Ctrl+b w` - выбрать окно из списка;
`Ctrl+b 0-9` - открыть окно по его номеру\
`Ctrl+b ,` - переименовать текущее окно\
`Ctrl+b %` - разделить текущую панель по горизонтали\
`Ctrl+b "` - разделить текущую панель по вертикали\
`Ctrl+b стрелка` - перейти на панель, находящуюся в стороне, куда указывает стрелка\
`Ctrl+b Ctrl+стрелка` - изменить размер текущей панели\
`Ctrl+b o` - перейти на следующую панель\
`Ctrl+b ;` - переключаться между текущей и предыдущей панелью\
`Ctrl+b x` - закрыть текущую панель\
`Ctrl+b [` - войти в режим копирования (подробнее ниже)\
`Ctrl+b ]` - вставить из внутреннего буфера обмена tmux\
`Ctrl+b d` - отключится от текущей сессии\
`Ctrl+b :` - открыть командную строку\

---

## Работающие процессы\
`ps auxf` - процессы и их дерево\  
`ps aux | less` - удобно смотерть процессы\
__опции без ТИРЕ для PS с тире - другие опции__\
`x` – убирает ограничение о процессах, запущенных из текущего терминала,\
`ax` – убирает ограничение о собственных процессах,\
`u` – добавляет расширенный набор часто нужных колонок,\
`f` - график\
`w/ww` – убирает ограничение по длине вывода\
`-u` - конкретного пользователя  
`ps ax -o stat --sort=stat` сортировка по статусу  
`-o` - можно выбрать поля для отображения\
`ps ax -o "stat %cpu command"` - 3 клонки\
`pgrep NAME` - полчить PID процесса\
еще ключи\
-e, -A — все процессы  
-t — только процессы этой консоли  
-N — инверсия (ps -N -t — все процессы, кроме этой консоли)  
-p <PID>,<PID> — просмотр процессов с заданным PID  
-С <строка> — просмотр процессов c заданной командой  
-U <username> — просмотр процессов заданного пользователя  
-G <group> — просмотр процессов заданной группы
 
  ### Мониторинг времени процессов\
  `time` - считает время выполнения\
  `vmstat TIME COUNT` - выводит статистику по загруженности машины \
   колонки `in` - interapt прерывание `cs` - contex switch - смена контекста\
  `taskset N` - количество ядер для запуска процесса\
  `taskset N -p PID` - количество ядер для запуска процесса поментяь для ПИДа\
 
  #### NICE
  параметр `nice` вежливость процесса от -20 до 19 - чем больше число - тем меньше процессорного времени получит\
 `nice -n` {приоритет} {программа} {аргументы}\
 `sudo nice -n` — если приоритет меньше 0\
 `renice -n {приоритет} PID` — для уже запущенного процесса\
 `renice -n -g -u` — для запущенной группы процессов, для пользователя\
 `ps ax -o pid,ni,cmd` — чтобы посмотреть nice запущенных процессов\
 
 sysctl kernel.sched_min_granularity_ns - переменная которая определяет кванты времения для переключения процессов
 время смены контекста
 
 __ionice__ - аналог nice для ввода-вывода
 
 
 
## Работа с памятью
`top` - \
`free` - свободная память\
`cat /proc/meminfo` - состояние памяти в ОС\
`grep -i inactive /proc/meminfo` - объем памяти которая не испоьзуется, но еще не очищена\

### Команды Linux для работы с кешем
sysctl -a | grep dirty — найти в настройках Linux параметры, которые используются при кешировании («грязные» страницы)

В файле /etc/sysctl.conf:
* vm.dirty_background_ratio = 10 — процент от памяти, 
которая может быть использована для хранения кеша перед записью на диск в фоновом режиме\
* vm.dirty_ratio = 15 — максимум памяти, который может быть выделен под кеш до записи на диск. При достижении этого значения ввод/вывод блокируется до освобождения кеша\
* vm.dirty_expire_centisecs = 3000 — время нахождения «грязных» страниц в кеше\
 
### Команды Linux для работы с кешем\
* sync — команда заставляет Linux записать все кешированные данные на диск
* echo 1 > /proc/sys/vm/drop_caches — очистка кеша PageCache
* echo 2 > /proc/sys/vm/drop_caches — очистка inode и dentrie
* echo 3 > /proc/sys/vm/drop_caches — очистка inode, dentrie и PageCache
 
 Программы mkswap, swapon, swapoff
* swapon -s; grep Swap /proc/meminfo; free -h — показывают использование файла подкачки
* mkswap /swapfile — размечает файл /swapfile как файловую систему SWAP
* swapoff\swapon /swapfile — отключение/подключение файла подкачки в систему
* cat /etc/fstab — выводит список устройств для монтирования. 

### Команды для тонкой настройки SWAP\
Посмотреть текущие / поменять до перезагрузки:
* /proc/sys/vm/vfs_cache_pressure — размер дискового кеша  
* /proc/sys/vm/swappiness — процент переноса данных в SWAP  
Для сохранения изменений после перезагрузки:\
 В файле /etc/sysctl.conf:
* vm.vfs_cache_pressure ={ваше значение} - размер дискового кеша
* vm.swappiness = {ваше значение} - процент памяти для переноса в кеш
* `sudo sysctl -p` - применить изменения из файла
 
`sudo sysctl vm.swappiness=30` - поменять размер памяти до начала использования кеша до перезагрузки
 
__SWАP использется на десктопах всегда, на серверах - по ситуации__\
__SWAP удобно делать как файл__\
`fallocate -l 1G /swapfile2` - создать пустой бинарный файл\
`chmod 0600 /swapfile2` - права\
`sudo mkswap /swapfile2` - форматировать \
`swapon /swapfile2` - подключить файл подкачки\
 
 #### Диск в памяти\
 `sudo mount -t tmpfs -o size=10M tmpfs /mnt/mytmpfs`\
 комманда, тип ФС, опции- размер, устройство, точка монтирвоания\
 
 ## БЛОЧНЫЕ УСТРОЙСТВА
`cat /proc/devices` – отображает список устройств, опознанных ядром\
`ls -la /dev/disks/by-*` – выводит информацию о дисках, подключенных к системе\
`ls -la /dev` – каталог специального назначения, который содержит файлы устройств.\
`lsblk` – list block devices\
`lshw -short -C disk, hdparm -I /dev/sda, smartctl --all /dev/nvme0` – утилиты, которые отображают информацию об имеющихся дисках с точки зрения железа

`/dev/mapper/vgdata-lvdata` — ссылки на устройства, созданные device mapper\
`/dev/dm-0, /dev/dm-1` — устройства, которые создаются device mapper\
`/dev/vgdata/lvdata` — ссылки на устройства, созданные device mapper\
`dmsetup ls` — отображает список устройств, созданных с помощью device

`lsblk` — утилита выводит список блочных устройств с информацией о них\
`blkid` — утилита отображает информацию об уникальных идентификаторах блочных устройств\
`fdisk` — утилита позволяет управлять разделами с разметкой MBR\
`gdisk` — утилита позволяет управлять разделами с разметкой GPT\
`parted` — утилита позволяет управлять разделами с разметкой MBR и GPT. В отличие от gdisk и fdisk изменения применяются сразу, не требуя подтверждения\
`cat /proc/partitions` — вывести список разделов
 
 `stat FILE` - параметры файла 
 
 ### Программный рейд
`sudo yum (apt-get) install mdadm` — установка утилиты\
`sudo mdadm --create /dev/md0 -l 1 -n 2 /dev/sd{b,c}` — создание нового массива\
`cat /proc/mdstat` — текущее состояние\
`/etc/mdadm.conf` — файл конфигурации

 ### LVM
`pvcreate` — позволяет создать физический том на жестком диске\
`vgcreate` — позволяет создать группу томов из физических томов\
`lvcreate` — позволяет создать логический том в группе томов\
`pvdisplay\pvs` — позволяет отобразить информацию о физических томах\
`vgdisplay\vgs` — позволяет отобразить информацию о группах томов в ОС\
`lvdisplay\lvs` — позволяет отобразить информацию о логических томах
 ### Мониторинг файловой системы
`top` — выводит информацию о работающих в системе процессах и информацию о них\
`iostat` — мониторинг использования дисковых разделов\
`iotop` — аналогична утилите top, но вместо использования процесcами CPU и памяти показывает работу процессов с дисками\
`vmstat 5 5` — утилита отображает информацию об использовании CPU, памяти, дисков\
`sar -p -d 5 3` — утилита для отображения различных параметров (статистики) работы системы
 
 
 #### Файловые сисетмы
* cat /proc/filesystems – вывести список файловых систем, которые поддерживаются ядром 
* fsck – утилита, с помощью которой можно проверить ФС на ошибки
* file -s /dev/sda1 – выводит тип файловой системы
* df -T – выводит тип файловой системы

* yum install dosfstools
* fdisk /dev/sd*
* mkfs.vfat -F 32 -n MyDrive /dev/sd*
* fatresize -s /dev/sd*

Для работы с NTFS может потребоваться установка пакетов:\
* yum install ntfs-3g — установка необходимых пакетов
* mount -t ntfs-3g /dev/sdb1 /mnt — монтирование NTFS в Linux

Команда для создания ext2 на разделе /dev/hdb1: 'mkfs -t ext2 /dev/hdb1'
Команда для создания ext4 на разделе /dev/hdb1: 'mkfs -t ext4 /dev/hdb1'

Команды для работы с XFS\
* mkfs.xfs /dev/sda1 — создание файловой системы
* xfs_info /dev/sda1 — выводит информацию про метаданные файловойсистемы.
* xfs_growfs / -d — увеличивает файловую систему на все доступное пространство
* xfs_check /dev/sdb1, xfs_repair /dev/sdb1 — проверяет файловую систему на ошибки

Команды для работы с Btrfs\
* mkfs.btrfs /dev/sdc -L single_drive — создание ФС на одном диске
* mkfs.btrfs /dev/sdc /dev/sdd -L double_drive — создание ФС на двух дисках
* sudo mkfs.btrfs /dev/sdc /dev/sdd -d raid1 -m raid1 -L raid1_drive — создать рейд средствами btrfs
* btrfs filesystem df / — получить информацию о ФС
* btrfs filesystem resize -2g /mnt — изменить размер тома в реальном времени

Команды для начала работы с автомонтированием:
* yum install autofs – установка пакета
* man auto.master – получение справки по пакету

Команды для начала работы с systemd-монтированием:
* systemctl list-units -t mount --all – вывести состояние всех описанных в systemd точек монтирования
* systemctl edit --full boot.mount – открыть на редактирование unit-файл

Команды Linux для работы с mount\
* mount -t ext4 -o noexec /dev/sdb6 /mnt – монтировать фс ext4 без возможности запускать исполняемые файлы на разделе
* mount --uuid="b386d309-05c1-42c8-8364-8d37270b69e0" /mnt – смонтировать раздел используя UUID
* mount --label="home" /mnt/ – монтировать раздел используя лейбл
* mount – вывести список всех смонтированных устройств
* umount /mnt – отмонтировать раздел, смонтированный по указанному пути

1 Regular file touch file1\
2 Directory mkdir mydir1\
3 Symbol link ln -s file1 link_to_file1\
4 Pipe mkfifo mypipe\
5 Socket -\
6 Block/symbol special file mknod <name> c/b <major> <minor>\
Создаем жесткую ссылку\
7 Hard link ln file1 second_name_file1\

* stat – утилита позволяет просматривать состояние файла и даже файловой системы\
* df -i – утилита выводит информацию о файловых системах, их размере,занятом и свободном пространстве и точках монтирования\
* ls -i – утилита отображает список файлов в каталоге\
* file -s /dev/sda3 – отобразить информацию о разделе\
 
__статус процессов__\
`R — выполняется  
D — uninterruptible sleep (ожидает ввод-вывод)  
S — interruptible sleep  
I — idle (бездействует > 20 секунд)  
T — приостановлен  
Z — зомби  
W — выгружен на диск (swap file)  
< — имеет повышенный приоритет  
N — имеет пониженный приоритет  
L — страницы заблокированы в ядре  
s — лидер сеанса (например, консоль)`


`echo -n D=; ps -A -o stat | grep D -c` считает количество процессов статуса D  
`pstree -a -p` - дерево процессов  
`lsof` - открытые файлы все  
*флаги*  
`lsof -p XXXX` - открытые файлы конкретного процесса  
`lsof -p $$` - открытые файлы текщей сессии баш вклюяая потоки ввода-вывода  
`lsof -u NAME` - открытые файлы пользователя  
`lsof -U` - открытые файлы сокетов. Сокеты - каналы обмена между процессами - лежат в памяти 
`lsof -c NAME` - файл открытые процессом  
`cat /dev/null > /proc/PID/fd/FD` - обнулить открытый файл PID процесса с FD  
или `echo > /proc/PID/fd/FD`  
`/proc/PID/fd/FD` - конкретный открытый файл  
 
 `sysstat` - пакет для слежения за процесами\
 `pidstat` - слежение за одним конкретным процессом\
 `pidstat -p PID 1` - раз в секунду выводить инфу по процессу\

## Сигналы процессам Работа с KILL  
`kill -l` - список возможных сигналов\
`kill -N PID` - отправить процессору сигнал N\
_1_ - SIGHUP - перечитать конфигурационный файл\
_2_ - SIGINT - завершить программу (ctrl+C)\
_9_ - SIGKILL - ппрервать немедленно без закрытия файлов - возможны ошибки\
_15_ - SIGTERM - корректно прервать программу с закрытием используемых файлов\ 
`kill -HUP $(cat /var/run/nginx.pid)` - Нередко HUP командует процессу перечитать свои конфигура 

## Настройка сети
`ip` - основная утилита
Для систем с графически интерфейсом есть Network Manager - в настройка или `nmcli`, `nmtui`\
Второй инструмент NetPlan - может ссылаться на NetworkManager `/etc/netplan/01-network-manager-all.yaml`\
В дистрибутивах родственных debian есть `/etc/network/interfaces`\

Netplan должен быть всегда, networkmanager - в десктопных версиях.

## DNS сервера

77.88.8.8 — Yandex  
77.88.8.1 — Yandex  
8.8.8.8 — Google  
8.8.4.4 — Google  

## vagrant  
`vagrant up` - запустить  
`vagrant suspend` - мягко выключить  
`vagrant halt` - жестко выключить  
`vagrant box add e3801813-59e0-4e69-8ace-78362d9f47cf --name bento/ubuntu20.04`  - добавить образ
`vagrant init bento/ubuntu20.04 `  инициализировать дирректорию  

## Мониторинг системных вызовов  
`strace` - моинторинг комманды  
*флаги* 
`strace -e KEY` - вывод только конкреных вызовов   
`strace -f ` - вывод дочерних процессов тоже  
`strace -p XXX ` - подключиться к конкретному процессу 
`strace -P XXX ` - системмные вызовы определенного пути  
`pidof NAME` - PID процесса с именем  
`strace -f sh -c ls` - следить за вызовами ls в sh  
`strace -f sh -c ls` `-c` - передать в sh комманду ls  
`strace -f bash -c 'cd /tmp'`  
`strace -s 65000` - вывести полные строки - по умолчанию 32 байта   
`strace -y` - аннотации к фаловым дискрипторам   
`strace -e openat` - фильтр по вызову    
 
 ### Выводы starce  
 openat - открывает файл и присваивает дескриптор  
 read - читает данные  
 close(3) - закрывает файл  
 write - пишет в файл  
 stat - пытается вызвать файл по переданному пути  

## Работа с руководством  
 *В руководстве много разделов и все они сразу не показываются, в документации есть ссылк ина них, например `man(2)`, ссылка на второй раздел*
`man NAME` - поиск справки по комманде  
`man bash` - справка по встроенным коммандам  
`man N NAME` - поиск справки по комманде в разделе N  
`man 7 man`  
`man -f man` - показать все разделы по комманде  
`man -k printf` - поиск комманд где есть `prinf`  
`man -k 'user ' | grep password` - поиск по комманде user где в тексте есть password  
*Поиск внутри руководства - нажимаем `/` пишем слово. Вперед - `n`, назад `N`*  
*Поиск внутри руководства - нажимаем `&` пишем слово. Все лишние строки скрываются,*  
*Внутри руководства нажимаем `-N` enter - показваюстя номера строки*  
*Внутри руководства нажимаем `-n` enter - убрать номера строки*  
*Внутри руководства нажимаем `234g` перейти на 234 строку*  
 
 `tldr NAME` - краткая справка  (too long document read)\
 
 `lynx` - браузер для консоли\

## Работа с SET  
*меняет режимы работы bash*  
`set` - текущие настройки    
`set -euxo pipefail` хорошо было бы использовать в сценариях - при ошибках обращения и выполнения - скрипт немедленно завершается и выполняется трассировка  


## Работа с Test 
*проверяет типы фалов и сравнивает значения*  
`test -d DIR` - существует ли путь и является ли дирректорией  
`test -e FILE` - существует ли файл  

### Работа с GREP  
`grep WHAT FILE` - поиск чегото в файл  
`-c` - подсчитать количество вхождений  
`-v` - исключить искомы строки в выводе  
`-i` - игнорировать регистр  
`grep '^vim'` - в начале строки стоит vim



## Мониторинг  системы   
`free -m` - использование памяти  
`echo 3 >/proc/sys/vm/drop_caches` - очистить кеш устройств  
`top` - монитор ресурсов, `shift+f` - управление  
_shift+ < >_ меяет сортировку\
`htop` - современный вариант top  
`atop` - запись в файл  
`iotop`  
`iftop`  

## Спящий режим
`cat /sys/power/mem_sleep` - поддерживаемы режимы сна  



```
Список полезной литературы  
«Unix и Linux: Руководство системного администратора», Эви Немет, Гарт Снайдер, Трент Хейн, Бен Уэйли, Дэн Макни.  
«TCP/IP. Сетевое администрирование», Хант Крэйг.  
«Компьютерные сети. Принципы, технологии, протоколы», Олифер Виктор Григорьевич, Олифер Наталия Алексеевна.  
«Компьютерные сети», Эндрю Таненбаум, Дэвид Уэзеролл.  
«Современные операционные системы», Эндрю Таненбаум, Херберт Бос.  
«Архитектура компьютера», Эндрю Таненбаум, Тодд Остин.  
«Установка, настройка, администрирование», Михаэль Кофлер.  
«Удалённый сервер своими руками. От азов создания до практической работы», Николай Левицкий.  
«Внутреннее устройство Linux», Брайан Уорд.  
«Администрирование сетей Cisco: освоение за месяц», Пайпер Б.  
«Сценарии командной оболочки. Linux, OS X и Unix». Серия «Для профессионалов».  
«Penetration Testing with the Bash shell», Keith Makan.  
«Pro Bash Programming Scripting the GNU/Linux Shell», Chris F. A. Johnson, Jayant Varma.  
```
